# PySNMP SMI module. Autogenerated from smidump -f python CISCO-PRIVATE-VLAN-MIB
# by libsmi2pysnmp-0.1.3 at Fri Aug  1 21:51:46 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( ciscoMgmt, ) = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
( vtpVlanEditEntry, vtpVlanEntry, ) = mibBuilder.importSymbols("CISCO-VTP-MIB", "vtpVlanEditEntry", "vtpVlanEntry")
( ifIndex, ) = mibBuilder.importSymbols("IF-MIB", "ifIndex")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Integer32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Integer32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks")
( TextualConvention, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue")

# Types

class PrivateVlanType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(5,1,2,4,3,)
    namedValues = NamedValues(("normal", 1), ("primary", 2), ("isolated", 3), ("community", 4), ("twoWayCommunity", 5), )
    
class VlanIndexBitmap(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(0,128)
    
class VlanIndexOrZero(Integer32):
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(0,4095)
    

# Objects

ciscoPrivateVlanMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 173)).setRevisions(("2005-09-08 00:00","2002-07-24 00:00","2001-05-23 00:00","2001-04-17 00:00",))
if mibBuilder.loadTexts: ciscoPrivateVlanMIB.setOrganization("Cisco Systems, Inc.")
if mibBuilder.loadTexts: ciscoPrivateVlanMIB.setContactInfo("Cisco Systems\nCustomer Service\n\nPostal: 170 W Tasman Drive\nSan Jose, CA  95134\nUSA\n\nTel: +1 800 553-NETS\n\nE-mail: cs-wbu@cisco.com")
if mibBuilder.loadTexts: ciscoPrivateVlanMIB.setDescription("The MIB module to support Private VLAN feature on\nCisco's switching devices.")
cpvlanMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 173, 1))
cpvlanVlanObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1))
cpvlanVlanTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1, 1))
if mibBuilder.loadTexts: cpvlanVlanTable.setDescription("A table containing Private VLAN information on the \nVLANs which currently exist.")
cpvlanVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1, 1, 1))
if mibBuilder.loadTexts: cpvlanVlanEntry.setDescription("A conceptual row containing the Private VLAN \ninformation on the VLANs for a particular management \ndomain.")
cpvlanVlanPrivateVlanType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1, 1, 1, 1), PrivateVlanType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpvlanVlanPrivateVlanType.setDescription("Indicated the VLAN type as defined for Private VLAN \nfeature.")
cpvlanVlanAssociatedPrimaryVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1, 1, 1, 2), VlanIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpvlanVlanAssociatedPrimaryVlan.setDescription("The VLAN ID of The associated primary VLAN used for \nthe Private VLAN feature if cpvlanVlanPrivateVlanType \nhas the value of isolated(3), community(4) or \ntwoWayCommunity(5). If cpvlanVlanPrivateVlanType \nhas the value of normal(1) or primary(2), then this \nobject has the value of 0.\n\nNote that one isolated VLAN can only be associated with \none unique primary VLAN. One primary VLAN can only be \nassociated with one isolated VLAN.\n\nOne primary VLAN can be associated with multiple VLANs \nof community or twoWayCommunity type; one community\nor twoWayCommunity VLAN can only be associated with one \nunique primary VLAN.")
cpvlanVlanEditTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1, 2))
if mibBuilder.loadTexts: cpvlanVlanEditTable.setDescription("A table containing Private VLAN information on the VLANs \nin the VLAN Edit Buffer for a particular management \ndomain.")
cpvlanVlanEditEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1, 2, 1))
if mibBuilder.loadTexts: cpvlanVlanEditEntry.setDescription("A conceptual row containing the Private VLAN information \non the VLANs in the VLAN Edit Buffer for a particular \nmanagement domain.")
cpvlanVlanEditPrivateVlanType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1, 2, 1, 1), PrivateVlanType().clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanVlanEditPrivateVlanType.setDescription("The VLAN type as defined for Private VLAN feature.\n\nNote that a VLAN's Private VLAN type can not be \nchanged once it already has any ports in it.")
cpvlanVlanEditAssocPrimaryVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 1, 2, 1, 2), VlanIndexOrZero().clone('0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanVlanEditAssocPrimaryVlan.setDescription("The VLAN ID of the associated primary VLAN used for \nthe Private VLAN feature if \ncpvlanVlanEditPrivateVlanType has the value of \nisolated(3), community(4), twoWayCommunity(5). If \ncpvlanVlanEditPrivateVlanType has the value of normal(1) \nor primary(2), then this object has the value of 0.\n\nNote that one isolated VLAN can only be associated \nwith one unique primary VLAN. One primary VLAN can only \nbe associated with one isolated VLAN.\n\nOne primary VLAN can be associated with multiple VLANs \nof community or twoWayCommunity type; one community \nor twoWayCommunity VLAN can only be associated with one \nunique primary VLAN.")
cpvlanPortObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2))
cpvlanPrivatePortTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 1))
if mibBuilder.loadTexts: cpvlanPrivatePortTable.setDescription("A table containing information of the configuration of \nsecondary VLAN on the ports of the device.")
cpvlanPrivatePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 1, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cpvlanPrivatePortEntry.setDescription("A conceptual row containing information of the \nconfiguration of secondary VLAN for each port. An entry \nis created by the managed system for each interface which\ncan be configured as a private port for Private VLAN \nfeature.")
cpvlanPrivatePortSecondaryVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 1, 1, 1), VlanIndexOrZero().clone('0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanPrivatePortSecondaryVlan.setDescription("The VLAN ID of the secondary VLAN configured on this \nprivate port. A private port is a port that allows \nthe ingress traffic of the secondary VLAN as well as \negress traffic of its associated primary VLAN, but \nblocks the egress traffic of the isolated VLAN while \nallowing the egress traffic of the community \nor twoWayCommunity VLAN depending on the type of the \nsecondary VLAN. \n\nNote that a port can join a secondary VLAN only after \nthis secondary VLAN has been associated with a primary \nVLAN, i.e., the cpvlanVlanAssociatedPrimaryVlan has a \nnon-zero value.  The default value of 0 for this object \nmeans this port has not joined any secondary VLAN yet.")
cpvlanPromPortTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 2))
if mibBuilder.loadTexts: cpvlanPromPortTable.setDescription("A table containing information of secondary VLAN to \nprimary VLAN remapping on ports of the device.")
cpvlanPromPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 2, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cpvlanPromPortEntry.setDescription("A conceptual row containing information of secondary \nVLAN to primary VLAN remapping for each port. An entry \nis created by the managed system for each interface\nwhich can be configured as a promiscuous port for \nPrivate VLAN feature.")
cpvlanPromPortMultiPrimaryVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 2, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpvlanPromPortMultiPrimaryVlan.setDescription("Indicates whether all the bits set as secondary VLANs\nin the corresponding remapping objects (i.e.\ncpvlanPromPortSecondaryRemap,\ncpvlanPromPortSecondaryRemap2k,\ncpvlanPromPortSecondaryRemap3k,\ncpvlanPromPortSecondaryRemap4k) can belong to multiple\nprimary VLANs or not for this port. If this object value\nis false(2), then the object values of \ncpvlanVlanAssociatedPrimaryVlan for the secondary VLANs \nwith their bits turned on as '1' in those remapping \nobjects must be the same. If this object value is \ntrue(1), then the object values of \ncpvlanVlanAssociatedPrimaryVlan for the secondary VLANs \nwith their bits turned on as '1' in those remapping \nobjects need not be the same. \n\nA promiscuous port can remap a secondary VLAN to its \nassociated primary VLAN for egress traffic on the fly \nas defined for Private VLAN feature.")
cpvlanPromPortSecondaryRemap = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanPromPortSecondaryRemap.setDescription("A string of octets containing one bit per VLAN in the\nmanagement domain on this port.  The first octet\ncorresponds to VLANs with VlanIndexOrZero values of 0 \nthrough 7; the second octet to VLANs 8 through 15; etc.  \nThe most significant bit of each octet corresponds to \nthe lowest value VlanIndexOrZero in that octet.\n\nA bit can only be set to '1' when the bit is \ncorresponding to a VLAN of Private VLAN isolated, \ncommunity or twoWayCommunity type which has already \nbeen associated with a primary VLAN. Setting this bit \nto '1' makes this promiscuous port remap the secondary \nVLAN to its associated primary VLAN for egress traffic \non the fly, or remap the associated primary VLAN to\nthe secondary VLAN if the secondary VLAN is of \ntwoWayCommunity type and the object value of \ncpvlanPromPortTwoWayRemapCapable for this promiscuous \nport is true(1).  \n\nNote that if the length of this string is less than\n128 octets, any 'missing' octets are assumed to contain\nthe value zero. An NMS may omit any zero-valued octets\nfrom the end of this string in order to reduce SetPDU \nsize, and the agent may also omit zero-valued trailing \noctets, to reduce the size of GetResponse PDUs.")
cpvlanPromPortSecondaryRemap2k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanPromPortSecondaryRemap2k.setDescription("A string of octets containing one bit per VLAN  for \nVLANs with VlanIndexOrZero values of 1024 through 2047 \nin the management domain on this port.  The first octet \ncorresponds to VLANs with VlanIndexOrZero values of 1024 \nthrough 1031; the second octet to VLANs 1032 through \n1039; etc.  The most significant bit of each octet \ncorresponds to the lowest value VlanIndexOrZero in \nthat octet. \n\nA bit can only be set to '1' when the bit is \ncorresponding to a VLAN of Private VLAN isolated or \ncommunity type which has already been associated with a \nprimary VLAN. Setting this bit to '1' makes this \npromiscuous port remap the secondary VLAN to its \nassociated primary VLAN for egress traffic on the fly,\nor remap the associated primary VLAN to the secondary \nVLAN if the secondary VLAN is of twoWayCommunity type \nand the object value of cpvlanPromPortTwoWayRemapCapable \nfor this promiscuous port is true(1). \n\nNote that if the length of this string is less than\n128 octets, any 'missing' octets are assumed to contain\nthe value zero. An NMS may omit any zero-valued octets\nfrom the end of this string in order to reduce SetPDU \nsize, and the agent may also omit zero-valued trailing \noctets, to reduce the size of GetResponse PDUs.\n\nThis object is only instantiated on devices which support\nthe range of VlanIndexOrZero up to 4095.")
cpvlanPromPortSecondaryRemap3k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanPromPortSecondaryRemap3k.setDescription("A string of octets containing one bit per VLAN  for \nVLANs with VlanIndexOrZero values of 2048 through 3071 \nin the management domain on this port.  The first octet \ncorresponds to VLANs with VlanIndexOrZero values of 2048 \nthrough 2055; the second octet to VLANs 2056 through \n2063; etc.  The most significant bit of each octet \ncorresponds to the lowest value VlanIndexOrZero in \nthat octet.\n\nA bit can only be set to '1' when the bit is \ncorresponding to a VLAN of Private VLAN isolated or \ncommunity type which has already been associated with a \nprimary VLAN. Setting this bit to '1' makes this \npromiscuous port remap the secondary VLAN to its \nassociated primary VLAN for egress traffic on the fly, \nor remap the associated primary VLAN to the secondary \nVLAN if the secondary VLAN is of twoWayCommunity type \nand the object value of cpvlanPromPortTwoWayRemapCapable \nfor this promiscuous port is true(1). \n\nNote that if the length of this string is less than\n128 octets, any 'missing' octets are assumed to contain\nthe value zero. An NMS may omit any zero-valued octets\nfrom the end of this string in order to reduce SetPDU \nsize, and the agent may also omit zero-valued trailing \noctets, to reduce the size of GetResponse PDUs.\n\nThis object is only instantiated on devices which support\nthe range of VlanIndexOrZero up to 4095.")
cpvlanPromPortSecondaryRemap4k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanPromPortSecondaryRemap4k.setDescription("A string of octets containing one bit per VLAN  for \nVLANs with VlanIndexOrZero values of 3072 through 4095 \nin the management domain on this port.  The first octet \ncorresponds to VLANs with VlanIndexOrZero values of 3072 \nthrough 3079; the second octet to VLANs 3080 through \n3087; etc.  The most significant bit of each octet \ncorresponds to the lowest value VlanIndexOrZero in \nthat octet.\n\nA bit can only be set to '1' when the bit is \ncorresponding to a VLAN of Private VLAN isolated or \ncommunity type which has already been associated with a \nprimary VLAN. Setting this bit to '1' makes this \npromiscuous port remap the secondary VLAN to its \nassociated primary VLAN for egress traffic on the fly, \nor remap the associated primary VLAN to the secondary \nVLAN if the secondary VLAN is of twoWayCommunity type \nand the object value of cpvlanPromPortTwoWayRemapCapable \nfor this promiscuous port is true(1). \n\nNote that if the length of this string is less than\n128 octets, any 'missing' octets are assumed to contain\nthe value zero. An NMS may omit any zero-valued octets\nfrom the end of this string in order to reduce SetPDU \nsize, and the agent may also omit zero-valued trailing \noctets, to reduce the size of GetResponse PDUs.\n\nThis object is only instantiated on devices which support\nthe range of VlanIndexOrZero up to 4095.")
cpvlanPromPortTwoWayRemapCapable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 2, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpvlanPromPortTwoWayRemapCapable.setDescription("Indicates whether the port is capable to perform\nremapping from primary VLANs to the twoWayCommunity VLANs\nassociated with them for the Private VLAN feature. A \npromiscuous port with this object value of false(2) can \nonly perform one-way remapping from secondary VLANs to \ntheir associated primary VLANs, while a promiscuous port \nwith this object value of true(1) can also perform \nremapping from primary VLANs to the twoWayCommunity VLANs \nassociated with them in addition to that.")
cpvlanPortModeTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 3))
if mibBuilder.loadTexts: cpvlanPortModeTable.setDescription("A table containing information of the configuration of\nport mode for the Private VLAN feature.")
cpvlanPortModeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 3, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cpvlanPortModeEntry.setDescription("A conceptual row containing information of the\nconfiguration of port mode on each port for the \nPrivate VLAN feature. An entry of this table is \ncreated by the managed system when the capability\nto be a Private VLAN port is detected on an \ninterface.")
cpvlanPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 3, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(5,4,1,3,2,)).subtype(namedValues=NamedValues(("nonPrivateVlan", 1), ("host", 2), ("promiscuous", 3), ("secondaryTrunk", 4), ("promiscuousTrunk", 5), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanPortMode.setDescription("The Private VLAN port mode on this port.  \n\nnonPrivateVlan(1) -- this port is configured to be a\n                     non-Private-VLAN port.\n\nhost(2) -- this port is configured to be \n           a Private-VLAN host port, i.e., private \n           port.\n\npromiscuous(3) -- this port is configured to be\n                  a Private-VLAN promiscuous port.\n\nsecondaryTrunk(4) -- this port is configured to be a\n            Private-VLAN isolated trunk port or community \n            trunk port.\n\npromiscuousTrunk(5) -- this port is configured to be a\n            Private-VLAN promiscuous trunk port.")
cpvlanTrunkPortTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4))
if mibBuilder.loadTexts: cpvlanTrunkPortTable.setDescription("A table containing information of the configuration of \na private vlan trunk port in the device. This includes \nsecondary and normal allowed VLAN, encapsulation type,\ntrunk native vlan (as applied to private vlan trunks).")
cpvlanTrunkPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cpvlanTrunkPortEntry.setDescription("A conceptual row containing information of the \nconfiguration of one private vlan trunk port. An entry \nis created by the managed system for each interface which\ncan be configured as a private vlan trunk port")
cpvlanTrunkPortDynamicState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("on", 1), ("onNoNegotiate", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortDynamicState.setDescription("For private VLAN trunk ports, this object allows the\noperator to mandate the trunking behavior of the port\n\non(1) dictates that the private VLAN port will always be a\ntrunk. If the negotiation is supported on this port, \nnegotiation will take place with the far end to attempt to\nbring the far end into trunking state.\n\nonNoNegotiate(2) is used to indicate that the interface is\npermanently set to be a trunk, and no negotiation takes\nplace with the far end on the link to ensure consistent\noperation. This is similar to on(1) except no negotiation\ntakes place with the far end.\n\nIf a port does not support negotiation, the value of on(1)\nis not allowed. If the port's cpvlanTrunkPortEncapType is \nset to negotiate(3), onNoNegotiate(2) is not allowed.")
cpvlanTrunkPortEncapType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("dot1Q", 1), ("isl", 2), ("negotiate", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortEncapType.setDescription("The type of VLAN encapsulation desired to be used on this\nprivate vlan trunk port. \n\nIt is either a particular type, or 'negotiate'  meaning \nwhatever type results from the negotiation.\n\ndot1Q(1) indicates that the port should accept and transmit\npackets with IEEE 802.1q VLAN encapsulation\n\nisl(2) indicates that the port should accept and transmit \npackets with Inter Switch Link (ISL) VLAN encapsulation\n\nnegotiate(3) indicates that the VLAN encapsulation is\nnegotiated with the far end. The negotiated VLAN \nencapsulation can be dot1Q or  isl. negotiate(2) is not \nallowed if the port does not support negotiation of \nVLAN encapsulation type or if its \ncpvlanTrunkPortDynamicState is set to onNoNegotiate(2)")
cpvlanTrunkPortNativeVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 3), VlanIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortNativeVlan.setDescription("The VlanIndex of the VLAN which is represented by native\nframes on this private vlan trunk port. For private vlan \ntrunk ports that need to drop untagged frames or not\nsupporting the sending and receiving of native frames, \nthis value should be set to zero")
cpvlanTrunkPortSecondaryVlans = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 4), VlanIndexBitmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortSecondaryVlans.setDescription("A string of octets containing one bit per VLAN for VLANs\nwith values of 0 through 1023 in the management domain\non this port. \n\nIf the VLAN represented by setting a bit to '1' in the \nbitmap is a secondary VLAN that has already been \nassociated with a primary VLAN, it allows this private\nVLAN trunk port to remap the secondary VLAN to its primary\nVLAN for ingress traffic and to remap its associated primary\nVLAN to the secondary VLAN for egress traffic.\n\nIf the bit corresponding to a VLAN is set to '1' and if \nthe corresponding VLAN is a secondary VLAN, then the local\nsystem is enabled to transmit and receive frames with \nproper VLAN remapping via this Private VLAN trunk port.\n\nIf the bit corresponding to a VLAN is set to '0', and if\nthe corresponding VLAN is not configured as a normal VLAN,\nthen the system is disabled from sending and receiving \nframes on that VLAN via this Private VLAN trunk port.")
cpvlanTrunkPortSecondaryVlans2k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 5), VlanIndexBitmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortSecondaryVlans2k.setDescription("A string of octets containing one bit per VLAN for VLANs \nwith values of 1024 through 2047 in the management domain\non this port. \n\nIf the VLAN represented by setting a bit to '1' in the \nbitmap is a secondary VLAN that has already been \nassociated with a primary VLAN, it allows this private\nVLAN trunk port to remap the secondary VLAN to its primary\nVLAN for ingress traffic and to remap its associated primary\nVLAN to the secondary VLAN for egress traffic.\n\nIf the bit corresponding to a VLAN is set to '1' and if \nthe corresponding VLAN is a secondary VLAN, then the local\nsystem is enabled to transmit and receive frames with \nproper VLAN remapping via this Private VLAN trunk port.\n\nIf the bit corresponding to a VLAN is set to '0', and if\nthe corresponding VLAN is not configured as a normal VLAN,\nthen the system is disabled from sending and receiving \nframes on that VLAN via this Private VLAN trunk port.\n\nThis object is only instantiated on devices which support\nthe range of VLANs up to 4095.")
cpvlanTrunkPortSecondaryVlans3k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 6), VlanIndexBitmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortSecondaryVlans3k.setDescription("A string of octets containing one bit per VLAN for VLANs \nwith values of 2048 through 3071 in the management domain \non this port. \n\nIf the VLAN represented by setting a bit to '1' in the \nbitmap is a secondary VLAN that has already been \nassociated with a primary VLAN, it allows this private\nVLAN trunk port to remap the secondary VLAN to its primary\nVLAN for ingress traffic and to remap its associated primary\nVLAN to the secondary VLAN for egress traffic.\n\nIf the bit corresponding to a VLAN is set to '1' and if \nthe corresponding VLAN is a secondary VLAN, then the local\nsystem is enabled to transmit and receive frames with \nproper VLAN remapping via this Private VLAN trunk port.\n\nIf the bit corresponding to a VLAN is set to '0', and if\nthe corresponding VLAN is not configured as a normal VLAN,\nthen the system is disabled from sending and receiving \nframes on that VLAN via this Private VLAN trunk port.\n\nThis object is only instantiated on devices which support\nthe range of up to 4095.")
cpvlanTrunkPortSecondaryVlans4k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 7), VlanIndexBitmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortSecondaryVlans4k.setDescription("A string of octets containing one bit per VLAN for VLANs \nwith values of 3072 through 4095 in the management domain\non this port. \n\nIf the VLAN represented by setting a bit to '1' in the \nbitmap is a secondary VLAN that has already been \nassociated with a primary VLAN, it allows this private\nVLAN trunk port to remap the secondary VLAN to its primary\nVLAN for ingress traffic and to remap its associated primary\nVLAN to the secondary VLAN for egress traffic.\n\nIf the bit corresponding to a VLAN is set to '1' and if \nthe corresponding VLAN is a secondary VLAN, then the local\nsystem is enabled to transmit and receive frames with \nproper VLAN remapping via this Private VLAN trunk port.\n\nIf the bit corresponding to a VLAN is set to '0', and if\nthe corresponding VLAN is not configured as a normal VLAN,\nthen the system is disabled from sending and receiving \nframes on that VLAN via this Private VLAN trunk port.\n\nThis object is only instantiated on devices which support\nthe range of up to 4095.")
cpvlanTrunkPortNormalVlans = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 8), VlanIndexBitmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortNormalVlans.setDescription("A string of octets containing one bit per VLAN for VLANs \nwith values of 0 through 1023 in the management domain \non this port.\n\nIf the VLAN represented by setting a bit to '1' in the \nbitmap is a normal VLAN, it allows packets belonging to\nthis vlan on this Private VLAN trunk port. \n\nIf the bit corresponding to a VLAN is set to '1' and if \nthe corresponding VLAN is a normal VLAN, then the local\nsystem is enabled to transmit and receive frames as\nnormal VLAN\n\nIf the bit corresponding to a VLAN is set to '0', and if\nthe corresponding VLAN is not configured as a secondary \nVLAN, then the system is disabled from sending and receiving\nframes on that VLAN via this Private VLAN trunk port.")
cpvlanTrunkPortNormalVlans2k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 9), VlanIndexBitmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortNormalVlans2k.setDescription("A string of octets containing one bit per VLAN for VLANs \nwith values of 1024 through 2047 in the management domain\non this port. \n\nIf the VLAN represented by setting a bit to '1' in the \nbitmap is a normal VLAN, it allows packets belonging to\nthis vlan on this Private VLAN trunk port. \n\nIf the bit corresponding to a VLAN is set to '1' and if \nthe corresponding VLAN is a normal VLAN, then the local\nsystem is enabled to transmit and receive frames as\nnormal VLAN\n\nIf the bit corresponding to a VLAN is set to '0', and if\nthe corresponding VLAN is not configured as a secondary \nVLAN, then the system is disabled from sending and receiving\nframes on that VLAN via this Private VLAN trunk port. \n\nThis object is only instantiated on devices which support\nthe range of VlanIndexOrZero up to 4095.")
cpvlanTrunkPortNormalVlans3k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 10), VlanIndexBitmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortNormalVlans3k.setDescription("A string of octets containing one bit per VLAN for VLANs \nwith values of 2048 through 3071 in the management domain\non this port. \n\nIf the VLAN represented by setting a bit to '1' in the \nbitmap is a normal VLAN, it allows packets belonging to\nthis vlan on this Private VLAN trunk port. \n\nIf the bit corresponding to a VLAN is set to '1' and if \nthe corresponding VLAN is a normal VLAN, then the local\nsystem is enabled to transmit and receive frames as\nnormal VLAN\n\nIf the bit corresponding to a VLAN is set to '0', and if\nthe corresponding VLAN is not configured as a secondary \nVLAN, then the system is disabled from sending and receiving\nframes on that VLAN via this Private VLAN trunk port. \n\nThis object is only instantiated on devices which support\nthe range of VlanIndexOrZero up to 4095.")
cpvlanTrunkPortNormalVlans4k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 11), VlanIndexBitmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanTrunkPortNormalVlans4k.setDescription("A string of octets containing one bit per VLAN for VLANs\nwith values of 3072 through 4095 in the management domain\non this port. \n\nIf the VLAN represented by setting a bit to '1' in the \nbitmap is a normal VLAN, it allows packets belonging to\nthis vlan on this Private VLAN trunk port. \n\nIf the bit corresponding to a VLAN is set to '1' and if \nthe corresponding VLAN is a normal VLAN, then the local\nsystem is enabled to transmit and receive frames as\nnormal VLAN\n\nIf the bit corresponding to a VLAN is set to '0', and if\nthe corresponding VLAN is not configured as a secondary \nVLAN, then the system is disabled from sending and receiving\nframes on that VLAN via this Private VLAN trunk port. \n\nThis object is only instantiated on devices which support\nthe range of VlanIndexOrZero up to 4095.")
cpvlanTrunkPortDynamicStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 12), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("trunking", 1), ("notTrunking", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpvlanTrunkPortDynamicStatus.setDescription("Indicates the current dynamic trunking status of the \nspecified private VLAN port.\n\ntrunking(1) indicates that the private VLAN port is \ncurrently operating as a private VLAN trunk port\n\nnotTrunking(2) indicates that the private VLAN port\nis currently not trunking but is operating as an \naccess port.")
cpvlanTrunkPortEncapOperType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 2, 4, 1, 13), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,)).subtype(namedValues=NamedValues(("dot1Q", 1), ("isl", 2), ("notApplicable", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpvlanTrunkPortEncapOperType.setDescription("The type of VLAN encapsulation in use on this private \nvlan trunk port. \n\ndot1Q(1) indicates that the port accepts and transmits\npackets with IEEE 802.1q VLAN encapsulation\n\nisl(2) indicates that the port accepts and transmits \npackets with Inter Switch Link (ISL) VLAN encapsulation\n\nIf the cpvlanTrunkPortDynamicStatus is notTrunking(2) or\nif the encapsulation type negotiation has not been \ncompleted, the object is set to notApplicable(3).")
cpvlanSVIObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 3))
cpvlanSVIMappingTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 3, 1))
if mibBuilder.loadTexts: cpvlanSVIMappingTable.setDescription("A table containing the configuration of \nprimary VLAN SVI (Switch Virtual Interfaces) \nmapping for the secondary VLANs for the Private \nVLAN feature.")
cpvlanSVIMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 3, 1, 1)).setIndexNames((0, "CISCO-PRIVATE-VLAN-MIB", "cpvlanSVIMappingVlanIndex"))
if mibBuilder.loadTexts: cpvlanSVIMappingEntry.setDescription("A conceptual row containing the Primary VLAN \nSVI mapping configuration for the existing \nsecondary VLANs. An entry is created by the managed \nsystem for each VLAN with corresponding VLAN's \ncpvlanVlanPrivateVlanType of isolated(3), \ncommunity(4), and twoWayCommunity(5).")
cpvlanSVIMappingVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 3, 1, 1, 1), VlanIndexOrZero()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cpvlanSVIMappingVlanIndex.setDescription("An index value that uniquely identifies the\nVirtual LAN associated with this information.")
cpvlanSVIMappingPrimarySVI = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 173, 1, 3, 1, 1, 2), VlanIndexOrZero().clone('0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpvlanSVIMappingPrimarySVI.setDescription("The Vlan ID of the primary VLAN SVI this secondary\nVLAN is mapped to for the Private VLAN feature. \nThis object has the value of zero if this secondary \nVLAN is not mapped to any primary VLAN SVI.")
cpvlanMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 173, 2))
cpvlanMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 1))
cpvlanMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 2))

# Augmentions
vtpVlanEntry, = mibBuilder.importSymbols("CISCO-VTP-MIB", "vtpVlanEntry")
vtpVlanEntry.registerAugmentions(("CISCO-PRIVATE-VLAN-MIB", "cpvlanVlanEntry"))
cpvlanVlanEntry.setIndexNames(*vtpVlanEntry.getIndexNames())
vtpVlanEditEntry, = mibBuilder.importSymbols("CISCO-VTP-MIB", "vtpVlanEditEntry")
vtpVlanEditEntry.registerAugmentions(("CISCO-PRIVATE-VLAN-MIB", "cpvlanVlanEditEntry"))
cpvlanVlanEditEntry.setIndexNames(*vtpVlanEditEntry.getIndexNames())

# Groups

cpvlanVlanGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 2, 1)).setObjects(*(("CISCO-PRIVATE-VLAN-MIB", "cpvlanVlanEditPrivateVlanType"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanVlanEditAssocPrimaryVlan"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanVlanPrivateVlanType"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanVlanAssociatedPrimaryVlan"), ) )
if mibBuilder.loadTexts: cpvlanVlanGroup.setDescription("A collection of objects providing basic VLAN \nconfiguration for Private VLAN feature.")
cpvlanPrivatePortGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 2, 2)).setObjects(*(("CISCO-PRIVATE-VLAN-MIB", "cpvlanPrivatePortSecondaryVlan"), ) )
if mibBuilder.loadTexts: cpvlanPrivatePortGroup.setDescription("A collection of objects providing basic \nprivate port configuration for Private VLAN \nfeature.")
cpvlanPromPortGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 2, 3)).setObjects(*(("CISCO-PRIVATE-VLAN-MIB", "cpvlanPromPortSecondaryRemap"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanPromPortTwoWayRemapCapable"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanPromPortMultiPrimaryVlan"), ) )
if mibBuilder.loadTexts: cpvlanPromPortGroup.setDescription("A collection of objects providing basic \npromiscuous port configuration for Private \nVLAN feature.")
cpvlanPromPort4kGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 2, 4)).setObjects(*(("CISCO-PRIVATE-VLAN-MIB", "cpvlanPromPortSecondaryRemap3k"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanPromPortSecondaryRemap4k"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanPromPortSecondaryRemap2k"), ) )
if mibBuilder.loadTexts: cpvlanPromPort4kGroup.setDescription("A collection of objects providing basic promiscuous \nport configuration for Private VLAN feature on \ndevices with VlanIndexOrZero range of up to 4095.")
cpvlanPortModeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 2, 5)).setObjects(*(("CISCO-PRIVATE-VLAN-MIB", "cpvlanPortMode"), ) )
if mibBuilder.loadTexts: cpvlanPortModeGroup.setDescription("This is an optional group with a collection of \nobjects providing basic port mode configuration for \nPrivate VLAN feature on devices which support \nPrivate VLAN port mode feature.")
cpvlanSVIMappingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 2, 6)).setObjects(*(("CISCO-PRIVATE-VLAN-MIB", "cpvlanSVIMappingPrimarySVI"), ) )
if mibBuilder.loadTexts: cpvlanSVIMappingGroup.setDescription("This is an optional group with a collection of \nobjects providing primary VLAN SVI mapping\nconfiguration for the Private VLAN feature on \ndevices which support Primary VLAN SVI mapping \nfeature.")
cpvlanTrunkPortGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 2, 7)).setObjects(*(("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortNativeVlan"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortNormalVlans3k"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortNormalVlans2k"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortDynamicState"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortNormalVlans"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortEncapType"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortSecondaryVlans"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortNormalVlans4k"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortDynamicStatus"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortEncapOperType"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortSecondaryVlans3k"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortSecondaryVlans2k"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortSecondaryVlans4k"), ) )
if mibBuilder.loadTexts: cpvlanTrunkPortGroup.setDescription("A collection of objects providing basic private VLAN\ntrunk port configuration for Private VLAN feature.")

# Compliances

cpvlanMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 173, 2, 1, 1)).setObjects(*(("CISCO-PRIVATE-VLAN-MIB", "cpvlanPrivatePortGroup"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanTrunkPortGroup"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanVlanGroup"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanPromPort4kGroup"), ("CISCO-PRIVATE-VLAN-MIB", "cpvlanPromPortGroup"), ) )
if mibBuilder.loadTexts: cpvlanMIBCompliance.setDescription("The compliance statement for Private VLAN feature \nimplementation.")

# Exports

# Module identity
mibBuilder.exportSymbols("CISCO-PRIVATE-VLAN-MIB", PYSNMP_MODULE_ID=ciscoPrivateVlanMIB)

# Types
mibBuilder.exportSymbols("CISCO-PRIVATE-VLAN-MIB", PrivateVlanType=PrivateVlanType, VlanIndexBitmap=VlanIndexBitmap, VlanIndexOrZero=VlanIndexOrZero)

# Objects
mibBuilder.exportSymbols("CISCO-PRIVATE-VLAN-MIB", ciscoPrivateVlanMIB=ciscoPrivateVlanMIB, cpvlanMIBObjects=cpvlanMIBObjects, cpvlanVlanObjects=cpvlanVlanObjects, cpvlanVlanTable=cpvlanVlanTable, cpvlanVlanEntry=cpvlanVlanEntry, cpvlanVlanPrivateVlanType=cpvlanVlanPrivateVlanType, cpvlanVlanAssociatedPrimaryVlan=cpvlanVlanAssociatedPrimaryVlan, cpvlanVlanEditTable=cpvlanVlanEditTable, cpvlanVlanEditEntry=cpvlanVlanEditEntry, cpvlanVlanEditPrivateVlanType=cpvlanVlanEditPrivateVlanType, cpvlanVlanEditAssocPrimaryVlan=cpvlanVlanEditAssocPrimaryVlan, cpvlanPortObjects=cpvlanPortObjects, cpvlanPrivatePortTable=cpvlanPrivatePortTable, cpvlanPrivatePortEntry=cpvlanPrivatePortEntry, cpvlanPrivatePortSecondaryVlan=cpvlanPrivatePortSecondaryVlan, cpvlanPromPortTable=cpvlanPromPortTable, cpvlanPromPortEntry=cpvlanPromPortEntry, cpvlanPromPortMultiPrimaryVlan=cpvlanPromPortMultiPrimaryVlan, cpvlanPromPortSecondaryRemap=cpvlanPromPortSecondaryRemap, cpvlanPromPortSecondaryRemap2k=cpvlanPromPortSecondaryRemap2k, cpvlanPromPortSecondaryRemap3k=cpvlanPromPortSecondaryRemap3k, cpvlanPromPortSecondaryRemap4k=cpvlanPromPortSecondaryRemap4k, cpvlanPromPortTwoWayRemapCapable=cpvlanPromPortTwoWayRemapCapable, cpvlanPortModeTable=cpvlanPortModeTable, cpvlanPortModeEntry=cpvlanPortModeEntry, cpvlanPortMode=cpvlanPortMode, cpvlanTrunkPortTable=cpvlanTrunkPortTable, cpvlanTrunkPortEntry=cpvlanTrunkPortEntry, cpvlanTrunkPortDynamicState=cpvlanTrunkPortDynamicState, cpvlanTrunkPortEncapType=cpvlanTrunkPortEncapType, cpvlanTrunkPortNativeVlan=cpvlanTrunkPortNativeVlan, cpvlanTrunkPortSecondaryVlans=cpvlanTrunkPortSecondaryVlans, cpvlanTrunkPortSecondaryVlans2k=cpvlanTrunkPortSecondaryVlans2k, cpvlanTrunkPortSecondaryVlans3k=cpvlanTrunkPortSecondaryVlans3k, cpvlanTrunkPortSecondaryVlans4k=cpvlanTrunkPortSecondaryVlans4k, cpvlanTrunkPortNormalVlans=cpvlanTrunkPortNormalVlans, cpvlanTrunkPortNormalVlans2k=cpvlanTrunkPortNormalVlans2k, cpvlanTrunkPortNormalVlans3k=cpvlanTrunkPortNormalVlans3k, cpvlanTrunkPortNormalVlans4k=cpvlanTrunkPortNormalVlans4k, cpvlanTrunkPortDynamicStatus=cpvlanTrunkPortDynamicStatus, cpvlanTrunkPortEncapOperType=cpvlanTrunkPortEncapOperType, cpvlanSVIObjects=cpvlanSVIObjects, cpvlanSVIMappingTable=cpvlanSVIMappingTable, cpvlanSVIMappingEntry=cpvlanSVIMappingEntry, cpvlanSVIMappingVlanIndex=cpvlanSVIMappingVlanIndex, cpvlanSVIMappingPrimarySVI=cpvlanSVIMappingPrimarySVI, cpvlanMIBConformance=cpvlanMIBConformance, cpvlanMIBCompliances=cpvlanMIBCompliances, cpvlanMIBGroups=cpvlanMIBGroups)

# Groups
mibBuilder.exportSymbols("CISCO-PRIVATE-VLAN-MIB", cpvlanVlanGroup=cpvlanVlanGroup, cpvlanPrivatePortGroup=cpvlanPrivatePortGroup, cpvlanPromPortGroup=cpvlanPromPortGroup, cpvlanPromPort4kGroup=cpvlanPromPort4kGroup, cpvlanPortModeGroup=cpvlanPortModeGroup, cpvlanSVIMappingGroup=cpvlanSVIMappingGroup, cpvlanTrunkPortGroup=cpvlanTrunkPortGroup)

# Compliances
mibBuilder.exportSymbols("CISCO-PRIVATE-VLAN-MIB", cpvlanMIBCompliance=cpvlanMIBCompliance)
